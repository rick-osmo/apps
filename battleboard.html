<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gray Scale Battleboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif; /* Use Inter font */
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }
        .battleboard-bg {
            background-color: #1a1a1a; /* Dark background */
        }
        .stage-column {
            min-height: 80vh; /* Ensure columns have height */
            padding: 1rem;
            border-right: 1px solid #444; /* Separator lines */
        }
        .stage-column:last-child {
            border-right: none;
        }
        .slot {
            width: 50px;
            height: 50px;
            border: 2px dashed #555; /* Dashed outline for empty slots */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 5px; /* Spacing between slots */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, border-style 0.2s ease-in-out;
        }
        .circle {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.8rem; /* Slightly smaller font for potential W-L record */
            color: #fff; /* Default text color */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            user-select: none;
            position: relative;
            text-align: center; /* Center text if it wraps */
            line-height: 1.2; /* Adjust line height */
        }
        .circle.dragging {
            opacity: 0.5;
            cursor: grabbing;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        .highlight-pair {
            box-shadow: 0 0 0 3px yellow;
        }
        /* Combined class for any valid drop target slot */
        .drop-target-slot {
             border-style: solid;
        }
        .drop-target-slot.win-target { /* Specific style for win section targets */
            border-color: #4ade80; /* Green */
            background-color: rgba(74, 222, 128, 0.1);
        }
        .drop-target-slot.loss-target { /* Specific style for loss section targets */
             border-color: #f87171; /* Red */
             background-color: rgba(248, 113, 113, 0.1);
        }
        .box-lid {
            min-height: 80vh;
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            gap: 10px;
            padding: 1rem;
            overflow-y: auto;
            transition: background-color 0.2s ease-in-out;
        }
        .box-lid.drop-target-final {
             background-color: rgba(74, 222, 128, 0.1);
             outline: 2px dashed #4ade80;
             outline-offset: -2px;
        }
        .box-lid .slot { /* Slots inside box lid are just containers */
             border: none;
             width: auto;
             height: auto;
             margin: 0;
             background-color: transparent !important;
             border-style: none !important;
        }
         /* Make circle slightly larger in box lid to accommodate text */
         .box-lid .circle {
             cursor: default;
             width: 55px;
             height: 55px;
             font-size: 0.75rem; /* Adjust font size if needed */
         }

        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
            font-size: 0.9rem;
            text-align: center;
        }

        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 10;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <div id="message-box"></div>

    <div class="container mx-auto p-4">
        <h1 class="text-2xl font-bold text-center mb-4">Gray Scale Battleboard</h1>

        <div class="flex justify-center space-x-4 mb-6">
            <button id="undo-button" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">Undo Last Move</button>
            <button id="reset-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out">Reset Game</button>
            <button id="download-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">Download Results</button>
        </div>

        <div class="battleboard-bg rounded-lg shadow-xl p-4 flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-2 overflow-x-auto">

            <div class="stage-column flex-shrink-0 w-full md:w-auto">
                <h2 class="text-lg font-semibold text-center mb-3">A (0-0)</h2>
                <div id="stage-A" class="grid grid-cols-2 gap-2 justify-items-center">
                    </div>
            </div>

            <div class="stage-column flex-shrink-0 w-full md:w-auto">
                <h2 class="text-lg font-semibold text-center mb-3">B</h2>
                <div class="mb-4">
                    <h3 class="text-md font-medium text-center text-green-400 mb-2">1-0</h3>
                    <div id="stage-B-1-0" class="grid grid-cols-2 gap-2 justify-items-center">
                        </div>
                </div>
                <div>
                    <h3 class="text-md font-medium text-center text-red-400 mb-2">0-1</h3>
                    <div id="stage-B-0-1" class="grid grid-cols-2 gap-2 justify-items-center">
                        </div>
                </div>
            </div>

            <div class="stage-column flex-shrink-0 w-full md:w-auto">
                <h2 class="text-lg font-semibold text-center mb-3">C</h2>
                 <div class="mb-4">
                    <h3 class="text-md font-medium text-center text-green-400 mb-2">2-0</h3>
                    <div id="stage-C-2-0" class="grid grid-cols-2 gap-2 justify-items-center">
                        </div>
                </div>
                 <div class="mb-4">
                    <h3 class="text-md font-medium text-center text-yellow-400 mb-2">1-1</h3>
                    <div id="stage-C-1-1" class="grid grid-cols-2 gap-2 justify-items-center">
                        </div>
                </div>
                <div>
                    <h3 class="text-md font-medium text-center text-red-400 mb-2">0-2</h3>
                    <div id="stage-C-0-2" class="grid grid-cols-2 gap-2 justify-items-center">
                        </div>
                </div>
            </div>

            <div class="stage-column flex-shrink-0 w-full md:w-auto">
                <h2 class="text-lg font-semibold text-center mb-3">D</h2>
                 <div class="mb-4">
                    <h3 class="text-md font-medium text-center text-green-400 mb-2">3-0</h3>
                    <div id="stage-D-3-0" class="grid grid-cols-2 gap-2 justify-items-center">
                        </div>
                </div>
                 <div class="mb-4">
                    <h3 class="text-md font-medium text-center text-yellow-400 mb-2">2-1</h3>
                    <div id="stage-D-2-1" class="grid grid-cols-2 gap-2 justify-items-center">
                        </div>
                </div>
                 <div class="mb-4">
                    <h3 class="text-md font-medium text-center text-orange-400 mb-2">1-2</h3>
                    <div id="stage-D-1-2" class="grid grid-cols-2 gap-2 justify-items-center">
                        </div>
                </div>
                 <div>
                    <h3 class="text-md font-medium text-center text-red-400 mb-2">0-3</h3>
                    <div id="stage-D-0-3" class="grid grid-cols-2 gap-2 justify-items-center">
                        </div>
                </div>
            </div>

            <div class="stage-column flex-grow w-full md:w-auto">
                 <h2 class="text-lg font-semibold text-center mb-3">Box Lid</h2>
                 <div id="box-lid" class="box-lid">
                     </div>
            </div>

        </div>
    </div>

    <script>
        // --- Configuration ---
        const NUM_COMPETITORS = 16;
        const MIN_SATURATION = 10; // Percent
        const MAX_SATURATION = 90; // Percent

        // --- Global State ---
        let circlesData = [];
        let battleHistory = [];
        let draggedCircleData = null;
        let currentOpponentData = null;

        // --- DOM Elements ---
        const stageA = document.getElementById('stage-A');
        const stageB_1_0 = document.getElementById('stage-B-1-0');
        const stageB_0_1 = document.getElementById('stage-B-0-1');
        const stageC_2_0 = document.getElementById('stage-C-2-0');
        const stageC_1_1 = document.getElementById('stage-C-1-1');
        const stageC_0_2 = document.getElementById('stage-C-0-2');
        const stageD_3_0 = document.getElementById('stage-D-3-0');
        const stageD_2_1 = document.getElementById('stage-D-2-1');
        const stageD_1_2 = document.getElementById('stage-D-1-2');
        const stageD_0_3 = document.getElementById('stage-D-0-3');
        const boxLid = document.getElementById('box-lid');
        const undoButton = document.getElementById('undo-button');
        const resetButton = document.getElementById('reset-button');
        const downloadButton = document.getElementById('download-button');
        const messageBox = document.getElementById('message-box');

        // --- Helper Functions ---

        function generateSaturations() {
            const saturations = new Set();
            const step = (MAX_SATURATION - MIN_SATURATION) / (NUM_COMPETITORS - 1);
            for (let i = 0; i < NUM_COMPETITORS; i++) {
                saturations.add(Math.round(MIN_SATURATION + i * step));
            }
            return Array.from(saturations).sort(() => Math.random() - 0.5);
        }

        function createCircleElement(circle) {
            const div = document.createElement('div');
            div.classList.add('circle');
            div.id = `circle-${circle.id}`;
            div.style.backgroundColor = `hsl(0, 0%, ${circle.saturation}%)`;
            div.style.color = circle.saturation > 50 ? '#000' : '#fff';
            // Initial text is just the ID
            div.textContent = circle.id;
            div.draggable = true;
            div.dataset.circleId = circle.id;
            div.dataset.tooltip = `${circle.wins}-${circle.losses} (Sat: ${circle.saturation}%)`;
            div.addEventListener('dragstart', handleDragStart);
            div.addEventListener('dragend', handleDragEnd);
            return div;
        }

        function createSlotElement(id, stage, wins = -1, losses = -1) {
            const div = document.createElement('div');
            div.classList.add('slot');
            div.id = id;
            div.dataset.stage = stage;
            if (wins !== -1) div.dataset.wins = wins; // Store expected W/L for the section
            if (losses !== -1) div.dataset.losses = losses;
            if (!id.startsWith('LID-')) {
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('dragenter', handleDragEnterSlot);
                div.addEventListener('dragleave', handleDragLeaveSlot);
                div.addEventListener('drop', handleDrop);
            }
            return div;
        }

        function findCircleDataById(id) {
            return circlesData.find(c => c.id === parseInt(id));
        }

        function findOpponent(circleData) {
            if (!circleData || !circleData.currentSlotId || circleData.currentSlotId.startsWith('LID')) return null;
            const currentSlot = document.getElementById(circleData.currentSlotId);
            if (!currentSlot || !currentSlot.parentElement) return null;
            const parentContainer = currentSlot.parentElement;
            const slots = Array.from(parentContainer.children).filter(el => el.classList.contains('slot') && el.id);
            const currentIndex = slots.findIndex(slot => slot.id === circleData.currentSlotId);
            if (currentIndex === -1) return null;
            const opponentIndex = currentIndex % 2 === 0 ? currentIndex + 1 : currentIndex - 1;
            if (opponentIndex >= 0 && opponentIndex < slots.length) {
                const opponentSlot = slots[opponentIndex];
                if (opponentSlot) {
                    const opponentCircleElement = opponentSlot.querySelector('.circle');
                    if (opponentCircleElement && opponentCircleElement.dataset.circleId) {
                        return findCircleDataById(opponentCircleElement.dataset.circleId);
                    }
                }
            }
             // Fallback check using stored opponentId (less reliable if DOM changes unexpectedly)
             if (circleData.opponentId) {
                 const opponent = findCircleDataById(circleData.opponentId);
                 if (opponent && opponent.currentSlotId) {
                     const opponentSlot = document.getElementById(opponent.currentSlotId);
                     if (opponentSlot && opponentSlot.parentElement === parentContainer) {
                         return opponent; // Ensure opponent is still in the same group
                     }
                 }
             }
            return null;
        }

        function findEmptySlot(stageId) {
            const stageContainer = document.getElementById(stageId);
            if (!stageContainer) return null;
            const slots = stageContainer.querySelectorAll('.slot');
            for (const slot of slots) {
                if (!slot.firstElementChild) { // Check if slot has no child elements
                    return slot;
                }
            }
            return null;
        }

        function getTargetStageInfo(currentWins, currentLosses, isWin) {
            const currentRound = currentWins + currentLosses;
            let nextWins = currentWins + (isWin ? 1 : 0);
            let nextLosses = currentLosses + (isWin ? 0 : 1);
            let targetStageId = null;

            // Determine the ID of the container for the next stage/section
            switch (currentRound) {
                case 0: targetStageId = isWin ? 'stage-B-1-0' : 'stage-B-0-1'; break;
                case 1:
                    if (currentWins === 1) targetStageId = isWin ? 'stage-C-2-0' : 'stage-C-1-1';
                    else targetStageId = isWin ? 'stage-C-1-1' : 'stage-C-0-2';
                    break;
                case 2:
                    if (currentWins === 2) targetStageId = isWin ? 'stage-D-3-0' : 'stage-D-2-1';
                    else if (currentWins === 1) targetStageId = isWin ? 'stage-D-2-1' : 'stage-D-1-2';
                    else targetStageId = isWin ? 'stage-D-1-2' : 'stage-D-0-3';
                    break;
                case 3: targetStageId = 'box-lid'; break; // Final move to Box Lid
                default: return null; // Invalid state
            }
            return { stageId: targetStageId, wins: nextWins, losses: nextLosses };
        }

        function clearHighlights() {
            document.querySelectorAll('.highlight-pair').forEach(el => {
                el.classList.remove('highlight-pair');
                el.style.boxShadow = '';
            });
            // Remove all drop target classes and reset styles
            document.querySelectorAll('.drop-target-slot').forEach(el => {
                el.classList.remove('drop-target-slot', 'win-target', 'loss-target');
                el.style.backgroundColor = '';
                if (!el.querySelector('.circle')) { // Only reset border if empty
                    el.style.borderStyle = 'dashed';
                    el.style.borderColor = '#555'; // Reset border color
                }
                 delete el.dataset.outcome; // Remove outcome marker
            });
             boxLid.classList.remove('drop-target-final');
             boxLid.style.backgroundColor = '';
             boxLid.style.outline = '';
             delete boxLid.dataset.outcome;
        }

        function updateButtonStates() {
            undoButton.disabled = battleHistory.length === 0;
            const circlesInLid = boxLid.querySelectorAll('.circle').length;
            downloadButton.disabled = circlesInLid !== NUM_COMPETITORS;
        }

        function showMessage(message, duration = 3000) {
             messageBox.textContent = message;
             messageBox.style.display = 'block';
             if (messageBox.timer) clearTimeout(messageBox.timer);
             messageBox.timer = setTimeout(() => {
                 messageBox.style.display = 'none';
                 messageBox.timer = null;
             }, duration);
         }

        // --- Drag and Drop Event Handlers ---

        function handleDragStart(event) {
            if (!event.target.classList.contains('circle')) { event.preventDefault(); return; }
            const circleElement = event.target;
            draggedCircleData = findCircleDataById(circleElement.dataset.circleId);
            if (!draggedCircleData) { console.error("DragStart Error: No data for", circleElement.dataset.circleId); event.preventDefault(); return; }

            if (draggedCircleData.currentSlotId?.startsWith('LID')) {
                 event.preventDefault();
                 showMessage("Circles cannot be moved from the Box Lid.", 2000);
                 return;
            }

            currentOpponentData = findOpponent(draggedCircleData);
            if (!currentOpponentData) {
                 showMessage("Cannot start drag: Opponent not found.", 2500);
                 event.preventDefault();
                 return;
            }

            event.dataTransfer.setData('text/plain', draggedCircleData.id);
            event.dataTransfer.effectAllowed = 'move';
            setTimeout(() => circleElement.classList.add('dragging'), 0);

            // Highlight pair
            draggedCircleData.element.classList.add('highlight-pair');
            currentOpponentData.element.classList.add('highlight-pair');

            // --- Highlight ALL valid drop targets in the next stage ---
            const winTargetInfo = getTargetStageInfo(draggedCircleData.wins, draggedCircleData.losses, true);
            const lossTargetInfo = getTargetStageInfo(draggedCircleData.wins, draggedCircleData.losses, false);

            // Highlight WIN section slots
            if (winTargetInfo && winTargetInfo.stageId !== 'box-lid') {
                const winStageContainer = document.getElementById(winTargetInfo.stageId);
                if (winStageContainer) {
                    winStageContainer.querySelectorAll('.slot').forEach(slot => {
                       if (!slot.firstElementChild) { // Only highlight empty slots
                            slot.classList.add('drop-target-slot', 'win-target');
                            slot.dataset.outcome = 'win'; // Mark as a 'win' outcome drop zone
                        }
                    });
                }
            }

            // Highlight LOSS section slots
            if (lossTargetInfo && lossTargetInfo.stageId !== 'box-lid') {
                const lossStageContainer = document.getElementById(lossTargetInfo.stageId);
                 if (lossStageContainer) {
                    lossStageContainer.querySelectorAll('.slot').forEach(slot => {
                       if (!slot.firstElementChild) { // Only highlight empty slots
                            slot.classList.add('drop-target-slot', 'loss-target');
                            slot.dataset.outcome = 'loss'; // Mark as a 'loss' outcome drop zone
                        }
                    });
                }
            }

            // Highlight BOX LID if it's the target
             if (winTargetInfo && winTargetInfo.stageId === 'box-lid') {
                 boxLid.classList.add('drop-target-final');
                 boxLid.dataset.outcome = 'final'; // Mark box lid as final drop zone
             }
        }

        function handleDragEnd(event) {
            setTimeout(() => {
                 if (event.target && event.target.classList) {
                    event.target.classList.remove('dragging');
                 }
                 clearHighlights();
                 draggedCircleData = null;
                 currentOpponentData = null;
            }, 0);
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnterSlot(event) {
             event.preventDefault();
             const targetSlot = event.target.closest('.slot');
             // Add hover effect only if it's a marked, empty drop target
             if (targetSlot && targetSlot.classList.contains('drop-target-slot') && !targetSlot.firstElementChild) {
                 if (targetSlot.classList.contains('win-target')) {
                     targetSlot.style.backgroundColor = 'rgba(74, 222, 128, 0.2)';
                 } else if (targetSlot.classList.contains('loss-target')) {
                     targetSlot.style.backgroundColor = 'rgba(248, 113, 113, 0.2)';
                 }
             }
        }

        function handleDragLeaveSlot(event) {
            const targetSlot = event.target.closest('.slot');
             // Remove hover effect, revert to base highlight color defined by class
             if (targetSlot && targetSlot.classList.contains('drop-target-slot')) {
                 if (targetSlot.classList.contains('win-target')) {
                     targetSlot.style.backgroundColor = 'rgba(74, 222, 128, 0.1)';
                 } else if (targetSlot.classList.contains('loss-target')) {
                     targetSlot.style.backgroundColor = 'rgba(248, 113, 113, 0.1)';
                 }
             }
        }

         function handleDragEnterLid(event) {
             event.preventDefault();
             if (boxLid.classList.contains('drop-target-final')) {
                 boxLid.style.backgroundColor = 'rgba(74, 222, 128, 0.2)';
             }
         }

         function handleDragLeaveLid(event) {
             // Check if leaving the lid itself or an element within it
             if (event.target === boxLid && boxLid.classList.contains('drop-target-final')) {
                  boxLid.style.backgroundColor = 'rgba(74, 222, 128, 0.1)';
             }
         }


        function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();

            const targetElement = event.target;
            // Find the intended drop target: a marked slot or the marked box lid
            const dropTarget = targetElement.closest('.drop-target-slot') || (targetElement.closest('.drop-target-final') ? boxLid : null);


            if (!dropTarget || !draggedCircleData || !currentOpponentData) {
                console.warn("Drop ignored: Invalid target or missing drag data.");
                clearHighlights(); // Still clear highlights on invalid drop
                return;
            }

            const draggedId = parseInt(event.dataTransfer.getData('text/plain'));
            if (draggedCircleData.id !== draggedId) {
                 console.error("Drop Error: Mismatched drag data.");
                 clearHighlights();
                 return;
            }

            const outcomeType = dropTarget.dataset.outcome; // 'win', 'loss', or 'final'
            const isTargetSlot = dropTarget.classList.contains('slot'); // Is it a specific slot or the lid?

            // --- Validation ---
            // 1. Must have a valid outcome type assigned during dragstart
             if (!outcomeType) {
                 showMessage("Invalid drop location.", 2000);
                 clearHighlights();
                 return;
             }
            // 2. If it's a slot (not the lid), it must be empty
            if (isTargetSlot && dropTarget.firstElementChild) {
                showMessage("This slot is already occupied.", 2000);
                clearHighlights();
                return;
            }

            // --- Determine Winner/Loser based on the drop target's outcome type ---
            let winnerData, loserData;
            let perceivedDarkerId, perceivedLighterId;

            if (outcomeType === 'win') { // Dropped onto a WIN slot/section
                winnerData = draggedCircleData;
                loserData = currentOpponentData;
            } else if (outcomeType === 'loss') { // Dropped onto a LOSS slot/section
                winnerData = currentOpponentData; // The *other* circle wins
                loserData = draggedCircleData;
            } else if (outcomeType === 'final') { // Dropped onto the BOX LID
                // Assume dragged circle 'wins' the final comparison for perception record
                winnerData = draggedCircleData;
                loserData = currentOpponentData;
            } else {
                console.error("Drop Error: Unknown outcome type:", outcomeType);
                clearHighlights();
                return;
            }
             // Record perception based on determined winner/loser
             perceivedDarkerId = winnerData.id;
             perceivedLighterId = loserData.id;


            // --- Calculate Next State (W-L records and target container IDs) ---
            const currentRound = winnerData.wins + winnerData.losses;
            const winnerTargetInfo = getTargetStageInfo(winnerData.wins, winnerData.losses, true);
            const loserTargetInfo = getTargetStageInfo(loserData.wins, loserData.losses, false);

            if (!winnerTargetInfo || !loserTargetInfo) {
                 console.error("Drop Error: Could not determine target stage info.");
                 clearHighlights();
                 return;
            }

            // --- Find Target Slots (first available in the correct section) ---
            let winnerTargetSlotElement, loserTargetSlotElement;

            if (winnerTargetInfo.stageId === 'box-lid') {
                // Create container slots dynamically in the Box Lid
                 winnerTargetSlotElement = createSlotElement(`LID-${winnerData.id}`, 'LID');
                 loserTargetSlotElement = createSlotElement(`LID-${loserData.id}`, 'LID');
                 boxLid.appendChild(winnerTargetSlotElement);
                 boxLid.appendChild(loserTargetSlotElement);
            } else {
                 // Find the first empty slot in the winner's target section
                 winnerTargetSlotElement = findEmptySlot(winnerTargetInfo.stageId);
                 // Find the first empty slot in the loser's target section
                 loserTargetSlotElement = findEmptySlot(loserTargetInfo.stageId);

                 // Critical Check: Ensure both slots were found
                 if (!winnerTargetSlotElement || !loserTargetSlotElement) {
                     showMessage("Could not find empty slots for both circles. Try undoing.", 3000);
                     console.error("Drop Error: Could not find empty slots in target stages:", winnerTargetInfo.stageId, loserTargetInfo.stageId);
                     // If Box Lid slots were created, remove them on error? No, this case is for non-lid drops.
                     clearHighlights();
                     return;
                 }
            }


            // --- Record Battle ---
            const battleRecord = {
                round: currentRound + 1,
                draggedCircleId: draggedCircleData.id,
                opponentCircleId: currentOpponentData.id,
                draggedCircleSat: draggedCircleData.saturation,
                opponentCircleSat: currentOpponentData.saturation,
                perceivedDarkerId: perceivedDarkerId,
                winnerId: winnerData.id,
                loserId: loserData.id,
                draggedCirclePrevSlotId: draggedCircleData.currentSlotId,
                opponentPrevSlotId: currentOpponentData.currentSlotId,
                winnerNewSlotId: winnerTargetSlotElement.id,
                loserNewSlotId: loserTargetSlotElement.id,
                timestamp: new Date().toISOString()
            };
            battleHistory.push(battleRecord);

            // --- Update Circle Data (State) ---
            winnerData.wins = winnerTargetInfo.wins;
            winnerData.losses = winnerTargetInfo.losses;
            winnerData.currentSlotId = winnerTargetSlotElement.id;
            winnerData.opponentId = null;

            loserData.wins = loserTargetInfo.wins;
            loserData.losses = loserTargetInfo.losses;
            loserData.currentSlotId = loserTargetSlotElement.id;
            loserData.opponentId = null;


            // --- Move Elements in DOM ---
            winnerTargetSlotElement.appendChild(winnerData.element);
            loserTargetSlotElement.appendChild(loserData.element);

            // --- Update Display (Tooltips and Box Lid Text) ---
            winnerData.element.dataset.tooltip = `${winnerData.wins}-${winnerData.losses} (Sat: ${winnerData.saturation}%)`;
            loserData.element.dataset.tooltip = `${loserData.wins}-${loserData.losses} (Sat: ${loserData.saturation}%)`;

             if (winnerTargetInfo.stageId === 'box-lid') {
                 // Update text content for circles in the box lid
                 winnerData.element.textContent = `${winnerData.id} (${winnerData.wins}-${winnerData.losses})`;
                 loserData.element.textContent = `${loserData.id} (${loserData.wins}-${loserData.losses})`;
                 // Make non-draggable
                 winnerData.element.draggable = false;
                 winnerData.element.style.cursor = 'default';
                 loserData.element.draggable = false;
                 loserData.element.style.cursor = 'default';
             }

            // --- Post-Drop Cleanup & Updates ---
            clearHighlights();
            updateButtonStates();

            if (boxLid.querySelectorAll('.circle').length === NUM_COMPETITORS) {
                showMessage("Battleboard Complete! Results ready for download.", 5000);
            }

            draggedCircleData = null;
            currentOpponentData = null;
        }


        // --- Control Functions ---

        function undoLastMove() {
            if (battleHistory.length === 0) return;
            const lastBattle = battleHistory.pop();

            const circle1 = findCircleDataById(lastBattle.draggedCircleId);
            const circle2 = findCircleDataById(lastBattle.opponentCircleId);
            const winner = findCircleDataById(lastBattle.winnerId);
            const loser = findCircleDataById(lastBattle.loserId);

            if (!circle1 || !circle2 || !winner || !loser) {
                console.error("Undo Error: Missing circle data for battle:", lastBattle);
                battleHistory.push(lastBattle); // Restore battle record
                showMessage("Error undoing move (data).", 3000);
                updateButtonStates();
                return;
            }

            const draggedPrevSlot = document.getElementById(lastBattle.draggedCirclePrevSlotId);
            const opponentPrevSlot = document.getElementById(lastBattle.opponentPrevSlotId);
            const winnerNewSlot = document.getElementById(lastBattle.winnerNewSlotId); // Slot it was moved TO
            const loserNewSlot = document.getElementById(lastBattle.loserNewSlotId);   // Slot it was moved TO

            if (!draggedPrevSlot || !opponentPrevSlot) {
                 console.error("Undo Error: Cannot find previous slots:", lastBattle.draggedCirclePrevSlotId, lastBattle.opponentPrevSlotId);
                 battleHistory.push(lastBattle);
                 showMessage("Error undoing move (slots).", 3000);
                 updateButtonStates();
                 return;
            }

            // --- Revert State ---
            // 1. Move elements back to original previous slots
            draggedPrevSlot.appendChild(circle1.element);
            opponentPrevSlot.appendChild(circle2.element);

            // 2. Remove temporary Box Lid slots if they exist
            if (lastBattle.winnerNewSlotId.startsWith('LID') && winnerNewSlot) winnerNewSlot.remove();
            if (lastBattle.loserNewSlotId.startsWith('LID') && loserNewSlot) loserNewSlot.remove();

            // 3. Revert W-L records from previous stage
             const winnerPrevRecord = getWLFromStage(winner === circle1 ? lastBattle.draggedCirclePrevSlotId : lastBattle.opponentPrevSlotId);
             const loserPrevRecord = getWLFromStage(loser === circle1 ? lastBattle.draggedCirclePrevSlotId : lastBattle.opponentPrevSlotId);

             if (winnerPrevRecord && loserPrevRecord) {
                 winner.wins = winnerPrevRecord.wins;
                 winner.losses = winnerPrevRecord.losses;
                 loser.wins = loserPrevRecord.wins;
                 loser.losses = loserPrevRecord.losses;
             } else {
                 console.error("Undo Warning: Could not parse W-L from previous slots:", lastBattle.draggedCirclePrevSlotId, lastBattle.opponentPrevSlotId);
                 // Attempt guess - less reliable
                 winner.wins = Math.max(0, winner.wins - 1);
                 loser.losses = Math.max(0, loser.losses - 1);
                 showMessage("Warning: Could not precisely revert W-L record.", 2500);
             }

            // 4. Revert currentSlotId
            circle1.currentSlotId = lastBattle.draggedCirclePrevSlotId;
            circle2.currentSlotId = lastBattle.opponentPrevSlotId;

            // 5. Restore appearance (draggable, text content, tooltip)
            circle1.element.draggable = true;
            circle1.element.style.cursor = 'grab';
            circle1.element.textContent = circle1.id; // Revert text to ID only
            circle1.element.dataset.tooltip = `${circle1.wins}-${circle1.losses} (Sat: ${circle1.saturation}%)`;

            circle2.element.draggable = true;
            circle2.element.style.cursor = 'grab';
            circle2.element.textContent = circle2.id; // Revert text to ID only
            circle2.element.dataset.tooltip = `${circle2.wins}-${circle2.losses} (Sat: ${circle2.saturation}%)`;

            // 6. Restore opponent references
            circle1.opponentId = circle2.id;
            circle2.opponentId = circle1.id;

            updateButtonStates();
            showMessage("Last move undone.", 1500);
        }

        function getWLFromStage(slotId) {
            if (!slotId || typeof slotId !== 'string' || slotId.startsWith('LID-')) return null;
            const parts = slotId.split('-');
            if (parts.length < 4) { console.warn(`getWLFromStage: Bad ID format: ${slotId}`); return null; }
            const stage = parts[0]; const winsStr = parts[1]; const lossesStr = parts[2];
            if (stage === 'A' && winsStr === '0' && lossesStr === '0') return { wins: 0, losses: 0 };
            const wins = parseInt(winsStr); const losses = parseInt(lossesStr);
            if (isNaN(wins) || isNaN(losses)) { console.warn(`getWLFromStage: Cannot parse W-L: ${slotId}`); return null; }
            return { wins, losses };
        }

        function downloadResults() {
            const circlesInLid = boxLid.querySelectorAll('.circle').length;
             if (circlesInLid !== NUM_COMPETITORS) { showMessage(`Game not finished. ${NUM_COMPETITORS - circlesInLid} circles remaining.`, 2500); return; }
             if (battleHistory.length === 0) { showMessage("No battles recorded yet.", 2500); return; }

            const finalPlacement = [];
            const finalCircles = boxLid.querySelectorAll('.circle');
             finalCircles.forEach(circleElement => {
                 const circleData = findCircleDataById(circleElement.dataset.circleId);
                 if (circleData) {
                     finalPlacement.push({
                         id: circleData.id,
                         saturation: circleData.saturation,
                         finalWins: circleData.wins,
                         finalLosses: circleData.losses,
                         finalSlotId: circleData.currentSlotId
                     });
                 }
             });

             finalPlacement.sort((a, b) => b.finalWins !== a.finalWins ? b.finalWins - a.finalWins : a.finalLosses - b.finalLosses);

            const resultsData = {
                gameType: "Gray Scale Battleboard",
                numCompetitors: NUM_COMPETITORS,
                gameCompletedTimestamp: new Date().toISOString(),
                battleHistory: battleHistory,
                finalPlacement: finalPlacement
            };

            const jsonString = JSON.stringify(resultsData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().slice(0, 10);
            a.download = `battleboard_results_${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function resetGame() {
            circlesData = [];
            battleHistory = [];
            draggedCircleData = null;
            currentOpponentData = null;

            [stageA, stageB_1_0, stageB_0_1, stageC_2_0, stageC_1_1, stageC_0_2,
             stageD_3_0, stageD_2_1, stageD_1_2, stageD_0_3, boxLid].forEach(container => {
                if(container) container.innerHTML = '';
            });

            const stageLayouts = {
                'stage-A': { count: 16, wins: 0, losses: 0, prefix: 'A-0-0' },
                'stage-B-1-0': { count: 8, wins: 1, losses: 0, prefix: 'B-1-0' },
                'stage-B-0-1': { count: 8, wins: 0, losses: 1, prefix: 'B-0-1' },
                'stage-C-2-0': { count: 4, wins: 2, losses: 0, prefix: 'C-2-0' },
                'stage-C-1-1': { count: 8, wins: 1, losses: 1, prefix: 'C-1-1' },
                'stage-C-0-2': { count: 4, wins: 0, losses: 2, prefix: 'C-0-2' },
                'stage-D-3-0': { count: 2, wins: 3, losses: 0, prefix: 'D-3-0' },
                'stage-D-2-1': { count: 6, wins: 2, losses: 1, prefix: 'D-2-1' },
                'stage-D-1-2': { count: 6, wins: 1, losses: 2, prefix: 'D-1-2' },
                'stage-D-0-3': { count: 2, wins: 0, losses: 3, prefix: 'D-0-3' },
            };

             for (const [stageId, layout] of Object.entries(stageLayouts)) {
                 if (stageId === 'stage-A') continue;
                 const container = document.getElementById(stageId);
                 if (container) {
                     for (let i = 0; i < layout.count; i++) {
                         const slotId = `${layout.prefix}-${i}`;
                         container.appendChild(createSlotElement(slotId, stageId, layout.wins, layout.losses));
                     }
                 } else { console.error(`Reset Error: Container not found: ${stageId}`); }
             }

            const saturations = generateSaturations();
            const stageALayout = stageLayouts['stage-A'];
            for (let i = 0; i < NUM_COMPETITORS; i++) {
                 const circle = { id: i + 1, saturation: saturations[i], wins: 0, losses: 0, element: null, currentSlotId: null, opponentId: null };
                 circle.element = createCircleElement(circle);
                 circlesData.push(circle);
                 const slotId = `${stageALayout.prefix}-${i}`;
                 const slotElement = createSlotElement(slotId, 'stage-A', 0, 0);
                 slotElement.appendChild(circle.element);
                 stageA.appendChild(slotElement);
                 circle.currentSlotId = slotId;
            }

             for (let i = 0; i < NUM_COMPETITORS; i += 2) {
                 if (circlesData[i] && circlesData[i+1]) {
                     circlesData[i].opponentId = circlesData[i+1].id;
                     circlesData[i+1].opponentId = circlesData[i].id;
                 }
             }

            updateButtonStates();
            showMessage("Game Reset!", 1500);
        }

        // --- Initialization ---
        resetButton.addEventListener('click', resetGame);
        undoButton.addEventListener('click', undoLastMove);
        downloadButton.addEventListener('click', downloadResults);
        boxLid.addEventListener('dragover', handleDragOver);
        boxLid.addEventListener('dragenter', handleDragEnterLid);
        boxLid.addEventListener('dragleave', handleDragLeaveLid);
        boxLid.addEventListener('drop', handleDrop);
        document.addEventListener('DOMContentLoaded', resetGame);

    </script>

</body>
</html>
